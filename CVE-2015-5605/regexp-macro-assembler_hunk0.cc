const byte* NativeRegExpMacroAssembler::StringCharacterPosition(
    String* subject,
    int start_index) {
  // Not just flat, but ultra flat.
  DCHECK(subject->IsExternalString() || subject->IsSeqString());
  DCHECK(start_index >= 0);
  DCHECK(start_index <= subject->length());
  if (subject->IsOneByteRepresentation()) {
    const byte* address;
    if (StringShape(subject).IsExternal()) {
      const uint8_t* data = ExternalOneByteString::cast(subject)->GetChars();
      address = reinterpret_cast<const byte*>(data);
    } else {
      DCHECK(subject->IsSeqOneByteString());
      const uint8_t* data = SeqOneByteString::cast(subject)->GetChars();
      address = reinterpret_cast<const byte*>(data);
    }
    return address + start_index;
  }
  const uc16* data;
  if (StringShape(subject).IsExternal()) {
    data = ExternalTwoByteString::cast(subject)->GetChars();
  } else {
    DCHECK(subject->IsSeqTwoByteString());
    data = SeqTwoByteString::cast(subject)->GetChars();
  }
  return reinterpret_cast<const byte*>(data + start_index);
}