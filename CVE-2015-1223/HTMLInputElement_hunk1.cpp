void HTMLInputElement::updateType()
{
    ASSERT(m_inputType);
    ASSERT(m_inputTypeView);
    const AtomicString& newTypeName = InputType::normalizeTypeName(fastGetAttribute(typeAttr));
    if (m_inputType->formControlType() == newTypeName)
        return;
    RefPtrWillBeRawPtr<InputType> newType = InputType::create(*this, newTypeName);
    removeFromRadioButtonGroup();
    bool didStoreValue = m_inputType->storesValueSeparateFromAttribute();
    bool didRespectHeightAndWidth = m_inputType->shouldRespectHeightAndWidthAttributes();
    m_inputTypeView->destroyShadowSubtree();
    lazyReattachIfAttached();
    m_inputType = newType.release();
    if (hasAuthorShadowRoot())
        m_inputTypeView = InputTypeView::create(*this);
    else
        m_inputTypeView = m_inputType;
    m_inputTypeView->createShadowSubtree();
    updateTouchEventHandlerRegistry();
    setNeedsWillValidateCheck();
    bool willStoreValue = m_inputType->storesValueSeparateFromAttribute();
    if (didStoreValue && !willStoreValue && hasDirtyValue()) {
        setAttribute(valueAttr, AtomicString(m_valueIfDirty));
        m_valueIfDirty = String();
    }
    if (!didStoreValue && willStoreValue) {
        AtomicString valueString = fastGetAttribute(valueAttr);
        m_inputType->warnIfValueIsInvalid(valueString);
        m_valueIfDirty = sanitizeValue(valueString);
    } else {
        if (!hasDirtyValue())
            m_inputType->warnIfValueIsInvalid(fastGetAttribute(valueAttr).string());
        updateValueIfNeeded();
    }
    m_needsToUpdateViewValue = true;
    m_inputTypeView->updateView();
    if (didRespectHeightAndWidth != m_inputType->shouldRespectHeightAndWidthAttributes()) {
        ASSERT(elementData());
        AttributeCollection attributes = attributesWithoutUpdate();
        if (const Attribute* height = attributes.find(heightAttr))
            attributeChanged(heightAttr, height->value());
        if (const Attribute* width = attributes.find(widthAttr))
            attributeChanged(widthAttr, width->value());
        if (const Attribute* align = attributes.find(alignAttr))
            attributeChanged(alignAttr, align->value());
    }
    if (document().focusedElement() == this)
        document().updateFocusAppearanceSoon(true /* restore selection */);
    setChangedSinceLastFormControlChangeEvent(false);
    addToRadioButtonGroup();
    setNeedsValidityCheck();
    notifyFormStateChanged();
}
